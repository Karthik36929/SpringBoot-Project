# Azure DevOps Pipeline for Spring Boot Deployment to AWS EKS
# This pipeline should be placed in the root of your Spring Boot project repository

trigger:
  branches:
    include: 
      - main
      - develop

pool:
  vmImage: 'ubuntu-latest'

variables:
  # Project Configuration
  - name: PROJECT_NAME
    value: '$(Build.Repository.Name)'
  - name: IMAGE_TAG
    value: '$(Build.BuildId)'
  
  # AWS Configuration (Set these in Azure DevOps Pipeline Variables or Variable Groups)
  - name: AWS_REGION
    value: 'eu-north-1'
  - name: AWS_ACCOUNT_ID
    value: '$(awsAccountId)'  # Set in pipeline variables
  - name: ECR_REPOSITORY
    value: 'greeting-api'
  - name: EKS_CLUSTER_NAME
    value: '$(eksClusterName)'  # Set in pipeline variables
  - name: K8S_NAMESPACE
    value: 'greeting-api'
  
  # AWS Credentials (Set these as SECRET variables in Azure DevOps)
  - name: AWS_ACCESS_KEY_ID
    value: '$(awsAccessKeyId)'  # Set as SECRET in pipeline variables
  - name: AWS_SECRET_ACCESS_KEY
    value: '$(awsSecretAccessKey)'  # Set as SECRET in pipeline variables
  
  # Java & Maven Configuration
  - name: JAVA_VERSION
    value: '17'
  - name: MAVEN_CACHE_FOLDER
    value: $(Pipeline.Workspace)/.m2/repository
  - name: MAVEN_OPTS
    value: '-Dmaven.repo.local=$(MAVEN_CACHE_FOLDER)'

stages:
- stage: Build
  displayName: 'Build Spring Boot Application'
  jobs:
  - job: BuildJob
    displayName: 'Maven Build & Test'
    steps:
    # Checkout code
    - checkout: self
      displayName: 'Checkout Repository'
    
    # Cache Maven dependencies
    - task: Cache@2
      inputs:
        key: 'maven | "$(Agent.OS)" | **/pom.xml'
        restoreKeys: |
          maven | "$(Agent.OS)"
          maven
        path: $(MAVEN_CACHE_FOLDER)
      displayName: 'Cache Maven Dependencies'
    
    # Run Maven tests
    - task: Maven@4
      inputs:
        mavenPomFile: 'pom.xml'
        goals: 'clean test'
        publishJUnitResults: true
        testResultsFiles: '**/surefire-reports/TEST-*.xml'
        codeCoverageToolOption: 'JaCoCo'
        mavenOptions: '-Xmx3072m $(MAVEN_OPTS)'
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '$(JAVA_VERSION)'
        jdkArchitectureOption: 'x64'
      displayName: 'Run Unit Tests'
    
    # Build JAR
    - task: Maven@4
      inputs:
        mavenPomFile: 'pom.xml'
        goals: 'package -DskipTests'
        publishJUnitResults: false
        mavenOptions: '-Xmx3072m $(MAVEN_OPTS)'
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '$(JAVA_VERSION)'
        jdkArchitectureOption: 'x64'
      displayName: 'Build Spring Boot Application'
    
    # Publish test results
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/surefire-reports/TEST-*.xml'
        mergeTestResults: true
        failTaskOnFailedTests: false
        testRunTitle: 'Spring Boot Unit Tests'
      displayName: 'Publish Test Results'
      condition: always()
    
    # Publish build artifacts
    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(System.DefaultWorkingDirectory)/target'
        artifact: 'spring-boot-jar'
        publishLocation: 'pipeline'
      displayName: 'Publish JAR Artifact'

- stage: Docker
  displayName: 'Build & Push Docker Image'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: DockerJob
    displayName: 'Docker Build & Push to ECR'
    steps:
    # Checkout code
    - checkout: self
      displayName: 'Checkout Repository'
    
    # Download build artifact
    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: 'spring-boot-jar'
        path: '$(System.DefaultWorkingDirectory)/target'
      displayName: 'Download JAR Artifact'
    
    # Install AWS CLI
    - script: |
        curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
        unzip awscliv2.zip
        sudo ./aws/install --update
        aws --version
      displayName: 'Install AWS CLI'
    
    # Configure AWS credentials and Login to ECR
    - task: Bash@3
      inputs:
        targetType: 'inline'
        script: |
          echo "Configuring AWS credentials..."
          aws sts get-caller-identity
          
          echo "Logging in to AWS ECR..."
          aws ecr get-login-password --region $(AWS_REGION) | docker login --username AWS --password-stdin $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com
          
          echo "Creating ECR repository if it doesn't exist..."
          aws ecr describe-repositories --repository-names $(ECR_REPOSITORY) --region $(AWS_REGION) || \
          aws ecr create-repository --repository-name $(ECR_REPOSITORY) --region $(AWS_REGION) --image-scanning-configuration scanOnPush=true
      env:
        AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_DEFAULT_REGION: $(AWS_REGION)
      displayName: 'Configure AWS & Login to ECR'
    
    # Build Docker image
    - script: |
        echo "Building Docker image..."
        docker build -t $(ECR_REPOSITORY):$(IMAGE_TAG) .
        docker tag $(ECR_REPOSITORY):$(IMAGE_TAG) $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com/$(ECR_REPOSITORY):$(IMAGE_TAG)
        docker tag $(ECR_REPOSITORY):$(IMAGE_TAG) $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com/$(ECR_REPOSITORY):latest
        echo "Docker image built successfully"
      displayName: 'Build Docker Image'
    
    # Push Docker image to ECR
    - task: Bash@3
      inputs:
        targetType: 'inline'
        script: |
          echo "Pushing Docker image to ECR..."
          docker push $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com/$(ECR_REPOSITORY):$(IMAGE_TAG)
          docker push $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com/$(ECR_REPOSITORY):latest
          echo "Docker image pushed successfully"
      env:
        AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_DEFAULT_REGION: $(AWS_REGION)
      displayName: 'Push Docker Image to ECR'

- stage: Deploy
  displayName: 'Deploy to AWS EKS'
  dependsOn: Docker
  condition: succeeded()
  jobs:
  - job: DeployJob
    displayName: 'Kubernetes Deployment'
    steps:
    # Checkout code (for k8s manifests)
    - checkout: self
      displayName: 'Checkout Repository'
    
    # Install kubectl
    - script: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
        kubectl version --client
      displayName: 'Install kubectl'
    
    # Configure kubectl for EKS
    - task: Bash@3
      inputs:
        targetType: 'inline'
        script: |
          # Update kubeconfig for EKS cluster
          aws eks update-kubeconfig --name $(EKS_CLUSTER_NAME) --region $(AWS_REGION)
          
          # Verify connection
          kubectl cluster-info
          kubectl get nodes
      env:
        AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_DEFAULT_REGION: $(AWS_REGION)
      displayName: 'Configure kubectl for EKS'
    
    # Create namespace if not exists
    - task: Bash@3
      inputs:
        targetType: 'inline'
        script: |
          kubectl create namespace $(K8S_NAMESPACE) --dry-run=client -o yaml | kubectl apply -f -
      env:
        AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_DEFAULT_REGION: $(AWS_REGION)
      displayName: 'Create Kubernetes Namespace'
    
    # Update image tags in k8s manifests
    - script: |
        # Update deployment.yaml with correct image
        sed -i "s|image:.*|image: $(AWS_ACCOUNT_ID).dkr.ecr.$(AWS_REGION).amazonaws.com/$(ECR_REPOSITORY):$(IMAGE_TAG)|g" k8s/deployment.yaml
        cat k8s/deployment.yaml
      displayName: 'Update K8s Manifests'
    
    # Apply Kubernetes manifests
    - task: Bash@3
      inputs:
        targetType: 'inline'
        script: |
          echo "Applying Kubernetes manifests..."
          kubectl apply -f k8s/namespace.yaml || echo "Namespace already exists"
          kubectl apply -f k8s/configmap.yaml -n $(K8S_NAMESPACE)
          kubectl apply -f k8s/deployment.yaml -n $(K8S_NAMESPACE)
          kubectl apply -f k8s/service.yaml -n $(K8S_NAMESPACE)
          kubectl apply -f k8s/ingress.yaml -n $(K8S_NAMESPACE) || echo "Ingress optional"
          kubectl apply -f k8s/hpa.yaml -n $(K8S_NAMESPACE) || echo "HPA optional"
          echo "Kubernetes manifests applied successfully"
      env:
        AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_DEFAULT_REGION: $(AWS_REGION)
      displayName: 'Deploy to Kubernetes'
    
    # Wait for deployment rollout with diagnostics
    - task: Bash@3
      inputs:
        targetType: 'inline'
        script: |
          echo "Waiting for deployment to complete..."
          kubectl rollout status deployment/greeting-api-deployment -n $(K8S_NAMESPACE) --timeout=10m || {
            echo "Deployment timeout! Checking pod status..."
            echo "=== Pod Status ==="
            kubectl get pods -n $(K8S_NAMESPACE) -l app=greeting-api
            echo ""
            echo "=== Pod Descriptions ==="
            kubectl describe pods -n $(K8S_NAMESPACE) -l app=greeting-api
            echo ""
            echo "=== Pod Logs ==="
            for pod in $(kubectl get pods -n $(K8S_NAMESPACE) -l app=greeting-api -o jsonpath='{.items[*].metadata.name}'); do
              echo "Logs for $pod:"
              kubectl logs $pod -n $(K8S_NAMESPACE) --tail=50 || echo "No logs available"
              echo "---"
            done
            exit 1
          }
      env:
        AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_DEFAULT_REGION: $(AWS_REGION)
      displayName: 'Wait for Deployment with Diagnostics'
    
    # Display deployment information
    - task: Bash@3
      inputs:
        targetType: 'inline'
        script: |
          echo "===== Deployment Status ====="
          kubectl get deployments -n $(K8S_NAMESPACE)
          echo ""
          echo "===== Pods ====="
          kubectl get pods -n $(K8S_NAMESPACE) -l app=greeting-api
          echo ""
          echo "===== Services ====="
          kubectl get services -n $(K8S_NAMESPACE)
          echo ""
          echo "===== Ingress ====="
          kubectl get ingress -n $(K8S_NAMESPACE) || echo "No ingress configured"
      env:
        AWS_ACCESS_KEY_ID: $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_DEFAULT_REGION: $(AWS_REGION)
      displayName: 'Display Deployment Info'
    
    # Run smoke tests (optional)
    - script: |
        echo "Running smoke tests..."
        # Get service endpoint
        SERVICE_IP=$(kubectl get service greeting-api-service -n $(K8S_NAMESPACE) -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        if [ -z "$SERVICE_IP" ]; then
          echo "Service IP not available yet, skipping smoke test"
          exit 0
        fi
        
        echo "Service available at: $SERVICE_IP"
        # Wait for service to be ready
        sleep 30
        
        # Test health endpoint
        curl -f http://$SERVICE_IP/actuator/health || echo "Health check failed (service might not be ready yet)"
      displayName: 'Run Smoke Tests'
      continueOnError: true
